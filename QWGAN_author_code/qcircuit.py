"""qWGAN original

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jgVluk51DzC64er6Nb_VGbEbS82v_RTa
"""

#!/usr/bin/env python

"""
    qcircuit.py: 量子ゲートと量子回路の関数・クラス

"""
import traceback
import numpy as np
import scipy.linalg as linalg
import os
import random
import sys
from scipy.sparse import dok_matrix

# 1量子ビットゲート
Ide = np.matrix(np.eye(2))
Pauli_X = np.matrix([[0, 1], [1, 0]])  #: Pauli-X matrix
Pauli_Y = np.matrix([[0, -1j], [1j, 0]])  #: Pauli-Y matrix
Pauli_Z = np.matrix([[1, 0], [0, -1]])  #: Pauli-Z matrix
Hadamard = np.matrix([[1, 1], [1, -1]]) / np.sqrt(2)  #: Hadamard gate

global param_table
param_table = dict()

def Identity(size):
    """
    Identityゲート
    
    Parameters
        size [int]量子ビット数
        
    Return 
        mat [np.matrix] (2**size)x(2**size)のIゲート
    """
    mat = 1
    for i in range(size):
        mat = np.kron(Ide, mat)
    return mat
    

# 1量子ビットゲート
def X(size, qubit, is_grad):
    """
    Xゲート
    args:
        size: int 量子ビット数
        qubit: int Xゲートを掛ける量子ビットのインデックス
        is_grad: bool 微分されているかどうか されていればTrue
        
    Return 
        mat [np.matrix] qubit番目の量子ビットにXゲートを掛けるための行列
    """
    mat = 1
    for i in range(size):
        if i == qubit:
            mat = np.kron(Pauli_X, mat)
        else:
            mat = np.kron(Ide, mat)
    return mat
    

def Y(size, qubit, is_grad):
    """
    Yゲート
    args:
        size: int 量子ビット数
        qubit: int Yゲートを掛ける量子ビットのインデックス
        is_grad: bool 微分されているかどうか されていればTrue
        
    Return 
        mat [np.matrix] qubit番目の量子ビットにYゲートを掛けるための行列
    """
    mat = 1
    for i in range(size):
        if i == qubit:
            mat = np.kron(Pauli_Y, mat)
        else:
            mat = np.kron(Ide, mat)
    return mat
    

def Z(size, qubit, is_grad):
    """
    Zゲート
    
    Parameters
        size  [int] 回路全体の量子ビット数
        qubit [int] Zゲートを掛ける量子ビットのインデックス
        is_grad [bool] 微分されているかどうか されていればTrue
        
    Return 
        mat [np.matrix] qubit番目の量子ビットにZゲートを掛けるための行列
    """
    mat = 1
    for i in range(size):
        if i == qubit:
            mat = np.kron(Pauli_Z, mat)
        else:
            mat = np.kron(Ide, mat)
    return mat
    

def H(size, qubit, is_grad):
    """
    Hゲート
    args:
        size: int 量子ビット数
        qubit: int Hadamardゲートを掛ける量子ビットのインデックス
        is_grad: bool 微分されているかどうか されていればTrue
        
    Return 
        mat [np.matrix] qubit番目の量子ビットにHゲートを掛けるための行列
    """
    mat = 1
    for i in range(size):
        if i == qubit:
            mat = np.kron(Hadamard, mat)
        else:
            mat = np.kron(Ide, mat)
    return mat
    

def qiskit_order(size):
    """
    行列の順番をqiskitのstatevectorのインデックスに合わせる
    
    Parameters
        size [int] 回路全体の量子ビット数
        
    Return
        states [list] statevectorの順番
    """
    states = []
    binary = ['0', '1']

    for i in binary:
        for j in binary:
            for k in binary:
                states.append(k+j+i)
    return states

def find_string_in_qiskit_order(size, string):
    """
    入力(string)がqiskitのstatevectorで何番目にあるか調べるもの
    
    Parameters
        size [int] 回路全体の量子ビット数
        string [str] '0'と'1'で構成された文字列
        
    Return
        index [int] stringがstatevectorの中で何番目か
    """
    order = qiskit_order(size)
    index = 0
    if string not in order:
        print("Put another string")
    for num in range(len(order)):
        if order[num] == string:
            index += num
    return index
    

def CNOT(nqubits, qubit1, qubit2, is_grad):
    """
    CNOTゲート
    
    Parameters
        size    [int]   回路全体の量子ビット数
        qubit1  [int]   control量子ビットのindex
        qubit2  [int]   target量子ビットのindex
        is_grad [bool]  微分されているかどうか
        
    Return
        mat [np.matrix] (2**nqubits)x(2**nqubits)の行列
    """
    if qubit1 > nqubits or qubit2 > nqubits or qubit1 == qubit2:
        print("You entered the wrong pair of qubits")

    # 2進数の長さ
    length = len(bin(nqubits)[2:])

    # 考えられるすべての状態
    states = [format(num,str(length).zfill(2)+'b').zfill(nqubits) for num in range(2**nqubits)]
    # 制御量子ビットが1のすべての状態(2進数方式)
    controlled_states = [state for state in states if state[qubit1]=='1']
    # 上の文字列を数値にした時の状態(整数)
    # 制御されるすべての状態
    target_states = []
    for state in controlled_states:
        # target qubitが0の時、1に反転させる
        if state[qubit2] == '0':
            state_list = list(state)
            state_list[qubit2] = '1'
            target_str = "".join(state_list)
        # target_int = int(target_str,2)
        # target qubitが1の時、0に反転させる
        else:
            state_list = list(state)
            state_list[qubit2] = '0'
            target_str = "".join(state_list)
            # target_int = int(target_str,2)
        target_states.append(target_str)
    # target_states.append(target_int)
    # #(2**nqubits)^2の正方行列
    mat = Identity(nqubits)
    mat = np.array(mat)
    for control, target in zip(controlled_states, target_states):
        cont_int = find_string_in_qiskit_order(nqubits,control)
        tar_int = find_string_in_qiskit_order(nqubits,target)
        mat[cont_int][cont_int] = 0
        mat[cont_int][tar_int] = 1
        mat[tar_int][cont_int] = 1
        mat[tar_int][tar_int] = 0

    return np.matrix(mat)
    

def single_RX(theta):
    """
    単体のRXゲート
    Parameters
        theta [float] 回転角
        
    Return
        mat [np.matrix] RXゲート(回転角 theta)
    """
    sin = np.sin(theta/2)
    cos = np.cos(theta/2)
    mat = np.array([[cos, -1J*sin],[-1J*sin, cos]])
    mat = np.matrix(mat)
    return mat
    

def single_RY(theta):
    """
    単体のRYゲート
    Parameters
        theta [float] 回転角
        
    Return
        mat [np.matrix] RYゲート(回転角 theta)
    """
    sin = np.sin(theta/2)
    cos = np.cos(theta/2)
    mat = np.array([[cos, -sin],[sin, cos]])
    mat = np.matrix(mat)
    return mat
    

def single_RZ(theta):
    """
    単体のRZゲート
    Parameters
        theta [float] 回転角
        
    Return
        mat [np.matrix] RZゲート(回転角 theta)
    """
    mat = np.array([[1,0],[0,np.exp(1J*theta)]])
    mat = np.matrix(mat)
    return mat

def RX(size, qubit, param, is_grad):
    """
    RXゲート
    Parameters
        size    [int] 回路全体の量子ビット数
        qubit   [int] RXゲートをかける量子ビットのインデックス
        param   [float] 回転角
        is_grad [bool] 微分されていればTrue、されていなければFalse
        
    Return
        matrix [np.matrix] qubit番目の量子ビットにRXゲート(回転角 param)をかけるための行列
    """
    matrix = 1
    for i in range(size):
        if qubit == i:
            if is_grad == False:
                try:
                    matrix = np.kron(single_RX(param),matrix)
                except Exception:
                    print('param:\n:', param)
            else:
                matrix = np.kron(-1J / 2 * Pauli_X * single_RX(param),matrix)
        else:
            matrix = np.kron(Ide,matrix)

    return matrix
    

def RY(size, qubit, param, is_grad):
    """
    RYゲート
    Parameters
        size    [int] 回路全体の量子ビット数
        qubit   [int] RYゲートをかける量子ビットのインデックス
        param   [float] 回転角
        is_grad [bool] 微分されていればTrue、されていなければFalse
        
    Return
        matrix [np.matrix] qubit番目の量子ビットにRYゲート(回転角 param)をかけるための行列
    """
    matrix = 1
    for i in range(size):
        if qubit == i:
            if is_grad == False:
                try:
                    matrix = np.kron(single_RY(param), matrix)
                except Exception:
                    print('param:\n:', param)
            else:
                matrix = np.kron(-1J / 2 * Pauli_Y * single_RY(param), matrix)
        else:
            matrix = np.kron(Ide, matrix)

    return matrix
    

def RZ(size, qubit, param, is_grad):
    """
    RZゲート
    Parameters
        size    [int] 回路全体の量子ビット数
        qubit   [int] RZゲートをかける量子ビットのインデックス
        param   [float] 回転角
        is_grad [bool] 微分されていればTrue、されていなければFalse
        
    Return
        matrix [np.matrix] qubit番目の量子ビットにRZゲート(回転角 param)をかけるための行列
    """
    matrix = 1
    for i in range(size):
        if qubit == i:
            if is_grad == False:
                try:
                    matrix = np.kron(single_RZ(param),matrix)
                except Exception:
                    print('param:\n:', param)
            else:
                matrix = np.kron(1J / 2 * Pauli_Z * single_RZ(param),matrix)
        else:
            matrix = np.kron(Ide, matrix)

    return matrix


class Quantum_Gate:
    def __init__(self, name, qubit1=None, qubit2=None, **kwarg):
        """
        量子ゲートのクラス
        
        Parameters
            name   [str] ゲートの名前
            qubit1 [int] 量子ゲートの1番目の量子ビット(1量子ビットゲートの量子ビット)
            qubit2 [int] 量子ゲートの2番目の量子ビット
            
            **kwarg
            -angle [float] 回転角
        """
        self.name = name
        self.qubit1 = qubit1
        self.qubit2 = qubit2
        self.r = self.get_r()
        self.s = self.get_s()

        if "angle" in kwarg:
            self.angle = kwarg["angle"]
        else:
            self.angle = None
            

    def get_r(self):
        if self.name == 'RX' or self.name == 'RY' or self.name == 'RZ' or self.name == 'ZZ':
            return 1/2
        elif self.name == 'XX' or self.name == 'YY':
            return 1
        else:
            return None

    def get_s(self):
        if self.r != None:
            return np.pi / (4 * self.r)
        else:
            return None

    def matrix_representation(self, size, is_grad):
        """
        ゲートの行列表現
        
        Parameters
            size    [int] 回路全体の量子ビット数
            is_grad [bool] 微分していればTrue、していなければFalse
        
        Return
            matrix [np.matrix] qubit1(とqubit2)にゲートをかけるための行列
        """
        if self.angle != None:
            try:
                param = float(self.angle)
            except:
                param = param_table[self.angle]

        elif (self.name == "RZ"):
            return RZ(size, self.qubit1, param, is_grad)

        elif (self.name == "RX"):
            return RX(size, self.qubit1, param, is_grad)

        elif (self.name == "RY"):
            return RY(size, self.qubit1, param, is_grad)

        elif (self.name == "Z"):
            return Z(size, self.qubit1, is_grad)

        elif (self.name == "X"):
            return X(size, self.qubit1, is_grad)

        elif (self.name == "Y"):
            return Y(size, self.qubit1, is_grad)
            
        elif (self.name == "H"):
            return Hadamard(size, self.qubit1, is_grad)

        elif (self.name == "CNOT"):
            return CNOT(size, self.qubit1, self.qubit2, param, is_grad)
        else:
            raise ValueError("Gate is not defined")

    def matrix_representation_shift_phase(self, size, is_grad, signal):
        """
        勾配を求める時に使うゲートの行列表現
        位相ずらす
        
        Parameters
            size    [int] 回路全体の量子ビット数
            is_grad [bool] 微分していればTrue、していなければFalse
            signal  [char] π/4足す時は'+'、π/4引く時は'-'、何もしない時は'0'
        
        Return
            matrix [np.matrix] qubit1(とqubit2)にゲートをかけるための行列
        """
        if self.angle != None:
            try:
                if self.name == 'G':
                    param = float(self.angle)
                else:
                    param = float(self.angle)
                    if is_grad == True:
                        if signal == '+':
                            param = param + self.s
                        else:
                            param = param - self.s
                        is_grad = False
            except:
                param = param_table[self.angle]

        elif (self.name == "RZ"):
            return RZ(size, self.qubit1, is_grad)

        elif (self.name == "RX"):
            return RX(size, self.qubit1, is_grad)

        elif (self.name == "RY"):
            return RY(size, self.qubit1, is_grad)

        elif (self.name == "Z"):
            return Z(size, self.qubit1, is_grad)

        elif (self.name == "X"):
            return X(size, self.qubit1, is_grad)

        elif (self.name == "Y"):
            return Y(size, self.qubit1, is_grad)
        
        elif (self.name == "H"):
            return Hadamard(size, self.qubit1, is_grad)
            
        elif (self.name == "CNOT"):
            # return mCNOT(size, self.qubit1, self.qubit2)
            return CNOT(size, self.qubit1, self.qubit2, param, is_grad)

        else:
            raise ValueError("Gate is not defined")


class Quantum_Circuit:

    def __init__(self, size, name):
        """
        量子回路のクラス
        Parameter
            size [int] 量子ビット数
            name [str] 量子ゲート名
        
        return: np.matrix (2**nqubits)x(2**nqubits)の行列
        """
        self.size = size
        self.depth = 0
        self.gates = []
        self.name = name

    def check_ciruit(self):
        """
        
        量子ゲート表記が正しいか調べる関数
        
        """
        for j,gate in zip(range(len(self.gates)),self.gates):
            if gate.qubit1!=None and gate.qubit2!=None:
                if gate.qubit1>self.size-1:
                    print('Error: #{} gate:{} 1qubit is out of range'.format(j, gate.name))
                    os._exit(0)
                elif gate.qubit2>self.size-1:
                    print('Error: #{} gate:{} 2qubit is out of range'.format(j, gate.name))
                    os._exit(0)
                    

    def get_mat_rep(self):
        """
        
        量子回路のゲート全体の行列を取得する関数
        
        """
        matrix = Identity(self.size)
        for gate in self.gates:
            g = gate.matrix_representation(self.size, False)
            matrix = np.matmul(g, matrix)
        return np.asmatrix(matrix)
        

    def get_grad_mat_rep(self, index, signal='none', type='matrix_multiplication'):
        """
        
        勾配を求めるために行列を計算する関数
        
        Parameter
            index  [int] ゲートをかける量子ビットのインデックス
            signal [char] π/4足す時は'+'、π/4引く時は'-'、何もしない時は'0'
            type   [str] 勾配を求める方法
            
        Return
            matrix [np.matrix] 量子回路全体の行列
            
        参考文献
        matrix multipliction: explicit way to calculate the gradient using matrix multiplication
        shift_phase: generate two quantum circuit to calculate the gradient
        Evaluating analytic gradients on quantum hardware
        https://arxiv.org/pdf/1811.11184.pdf
        
        """
        if type == 'shift_phase':
            matrix = Identity(self.size)
            for j, gate in zip(range(len(self.gates)), self.gates):
                if index == j:
                    g = gate.matrix_representation_shift_phase(self.size, True, signal)
                    matrix = np.matmul(g, matrix)
                else:
                    g = gate.matrix_representation_shift_phase(self.size, False, signal)
                    matrix = np.matmul(g, matrix)
            return np.asmatrix(matrix)

        elif type == 'matrix_multiplication':
            matrix = Identity(self.size)
            for j, gate in zip(range(len(self.gates)), self.gates):
                if index == j:
                    g = gate.matrix_representation(self.size, True)
                    matrix = np.matmul(g, matrix)
                else:
                    g = gate.matrix_representation(self.size, False)
                    matrix = np.matmul(g, matrix)
            return np.asmatrix(matrix)
            

    def get_grad_qc(self,indx,type='0'):
        """
        
        Parameters
            index1 [int] 1番目の量子ビット
            index2 [int] 2番目の量子ビット
            type   [char] π/4足す時は'+'、π/4引く時は'-'、何もしない時は'0'
        
        return: np.matrix (2**nqubits)x(2**nqubits)の行列
        
        """
        qc_list = list()
        for j,gate in zip(range(len(self.gates)),self.gates):
            tmp = Quantum_Gate(' ',qubit1=None,qubit2=None,angle=None)
            tmp.name = gate.name
            tmp.qubit1 = gate.qubit1
            tmp.qubit2 = gate.qubit2
            tmp.angle = gate.angle
            if j == indx:
                try:
                    if self.gates[j].name != 'G' or self.gates[j].name !='CNOT':
                        if type == '+':
                            tmp.angle = gate.angle + gate.s
                        elif type == '-':
                            tmp.angle = gate.angle - gate.s
                except:
                    print('param value error')
                qc_list.append(tmp)
            else:
                qc_list.append(tmp)
        return qc_list

    def add_gate(self, quantum_gate):
        """
        
        量子回路にゲートを追加する関数
        
        Parameter
            quantum_gate [QuantumGate] 追加する量子ゲート
            
        """
        self.depth += 1
        self.gates.append(quantum_gate)